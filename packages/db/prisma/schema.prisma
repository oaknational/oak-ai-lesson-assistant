// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions", "multiSchema"]
}

datasource db {
  provider   = "postgresql"
  url        = env("PRISMA_ACCELERATE_DATABASE_URL")
  directUrl  = env("DIRECT_DATABASE_URL")
  extensions = [vector, pg_trgm]
  schemas    = ["public", "ingest", "rag", "additional_materials"]
}

generator zod {
  provider = "zod-prisma"
  output   = "./zod-schemas"

  relationModel         = true
  modelCase             = "camelCase"
  modelSuffix           = "Model"
  useDecimalJs          = false
  // imports               = null
  prismaJsonNullability = true
}

model App {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  prompts     Prompt[]
  appSessions AppSession[]
  statistics  Statistics[]

  @@map("apps")
  @@schema("public")
}

model Prompt {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  name         String
  slug         String
  identifier   String?
  version      Int      @default(0)
  app          App      @relation(fields: [appId], references: [id], onDelete: Cascade)
  appId        String   @map("app_id")
  hash         String   @unique
  variant      String?
  current      Boolean  @default(true)
  gitSha       String?  @map("git_sha")
  template     String // The prompt body
  inputSchema  Json     @map("input_schema") // A JSON-schema to apply to prompt inputs
  outputSchema Json     @map("output_schema") // A JSON-schema to apply to completions

  statistics                        Statistics[]
  AnswersAndDistractorsForJudgement AnswersAndDistractorsForJudgement[]

  @@map("prompts")
  @@schema("public")
}

// Clerk users
// Clerk is to be considered the source of truth for this table,
// but we're storing the derived data as joining against clerk's
// API makes analysis and filtering harder
//
// n.b. user_id columns are not currently set as relations
//      but will be in future once this is complete
model User {
  id        String   @id // Defined by clerk, aka user_*****
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  isOakUser Boolean @map("is_oak_user")

  // Email addresses should ONLY be stored when isOakUser is
  // true. A constraint has been manually added via migrations
  // to make sure we only track internal users emails
  emailAddress String? @map("email_address")

  @@map("users")
  @@schema("public")
}

model KeyStage {
  id                    String                  @id @default(cuid())
  title                 String
  slug                  String                  @unique
  createdAt             DateTime                @default(now()) @map("created_at")
  updatedAt             DateTime                @updatedAt @map("updated_at")
  KeyStageSubjects      KeyStageSubject[]
  Lessons               Lesson[]
  Snippet               Snippet[]
  LessonSummary         LessonSummary[]
  QuestionsForJudgement QuestionsForJudgement[]
  LessonPlanParts       LessonPlanPart[]
  LessonPlan            LessonPlan[]

  @@map("key_stages")
  @@schema("public")
}

model KeyStageSubject {
  id               String   @id @default(cuid())
  keyStageId       String   @map("key_stage_id")
  subjectId        String   @map("subject_id")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")
  contentAvailable Boolean  @default(false)

  keyStage KeyStage @relation(fields: [keyStageId], references: [id], onDelete: Cascade)
  subject  Subject  @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  @@unique([keyStageId, subjectId])
  @@map("key_stage_subjects")
  @@schema("public")
}

model AilaUserFlag {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  userId       String           @map("user_id")
  chatId       String           @map("chat_id")
  messageId    String           @map("message_id")
  sectionPath  String?          @map("section_path")
  sectionValue Json?            @map("section_value") @db.JsonB
  flagType     AilaUserFlagType @map("flag_type")
  userComment  String?          @map("user_comment")

  @@map("chat_user_flags")
  @@schema("public")
}

enum AilaUserFlagType {
  INAPPROPRIATE
  INACCURATE
  TOO_HARD
  TOO_EASY
  OTHER

  @@schema("public")
}

model AilaUserModification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  userId          String                     @map("user_id")
  chatId          String                     @map("chat_id")
  messageId       String                     @map("message_id")
  textForMod      String?                    @map("text_for_mod")
  sectionPath     String?                    @map("section_path")
  sectionValue    Json?                      @map("section_value") @db.JsonB
  actionOtherText String?                    @map("action_other_text")
  action          AilaUserModificationAction @map("action")

  @@map("aila_user_modifications")
  @@schema("public")
}

enum AilaUserModificationAction {
  MAKE_IT_HARDER
  MAKE_IT_EASIER
  SHORTEN_CONTENT
  ADD_MORE_DETAIL
  ADD_HOMEWORK_TASK
  ADD_NARRATIVE
  ADD_PRACTICE_QUESTIONS
  TRANSLATE_KEYWORDS
  ADD_PRACTICAL_INSTRUCTIONS
  OTHER

  @@schema("public")
}

model Subject {
  id                    String                  @id @default(cuid())
  title                 String
  slug                  String                  @unique
  createdAt             DateTime                @default(now()) @map("created_at")
  updatedAt             DateTime                @updatedAt @map("updated_at")
  KeyStageSubjects      KeyStageSubject[]
  Lessons               Lesson[]
  Snippet               Snippet[]
  LessonSummary         LessonSummary[]
  QuestionsForJudgement QuestionsForJudgement[]
  LessonPlanParts       LessonPlanPart[]
  LessonPlans           LessonPlan[]

  @@map("subjects")
  @@schema("public")
}

model Lesson {
  id               String   @id @default(cuid())
  title            String
  slug             String   @unique
  keyStageName     String   @map("key_stage")
  keyStageId       String?  @map("key_stage_id")
  subjectId        String?  @map("subject_id")
  content          Json?
  newLessonContent Json?    @map("new_lesson_content")
  captions         Json?
  isNewLesson      Boolean  @default(false) @map("is_new_lesson")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  snippets    Snippet[]
  transcripts Transcript[]
  summaries   LessonSummary[]
  questions   QuizQuestion[]
  answers     QuizAnswer[]
  keyStage    KeyStage?       @relation(fields: [keyStageId], references: [id], onDelete: Cascade)
  subject     Subject?        @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  Downloads   Downloads[]
  lessonPlans LessonPlan[]

  @@map("lessons")
  @@schema("public")
}

model SummarisationStrategy {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  name        String
  description String
  prompt      String
  promptHash  String @map("prompt_hash")
  chunkSize   Int?   @map("chunk_size")

  summaries LessonSummary[]

  @@map("summarisation_strategies")
  @@schema("public")
}

model LessonSummary {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  lessonId           String                       @map("lesson_id")
  strategyId         String?                      @map("strategy_id")
  content            String?
  topics             String[]
  learningObjectives String[]
  concepts           String[]
  keywords           String[]
  reasoning          String?
  errorMessage       String?
  captions           Json?
  subjectId          String?                      @map("subject_id")
  keyStageId         String?                      @map("key_stage_id")
  subjectSlug        String?
  keyStageSlug       String?
  embedding          Unsupported("vector(1536)")?
  status             LessonSummaryStatus          @default(PENDING)
  error              String?

  lesson   Lesson                 @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  strategy SummarisationStrategy? @relation(fields: [strategyId], references: [id], onDelete: Cascade)
  keyStage KeyStage?              @relation(fields: [keyStageId], references: [id], onDelete: Cascade)
  subject  Subject?               @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  @@map("lesson_summaries")
  @@schema("public")
}

model LessonPlan {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  lessonId     String                       @map("lesson_id")
  subjectId    String?                      @map("subject_id")
  keyStageId   String?                      @map("key_stage_id")
  content      Json?
  errorMessage String?
  embedding    Unsupported("vector(1536)")?
  status       LessonPlanStatus             @default(PENDING)
  parts        LessonPlanPart[]

  lesson   Lesson    @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  subject  Subject?  @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  keyStage KeyStage? @relation(fields: [keyStageId], references: [id], onDelete: Cascade)

  @@map("lesson_plans")
  @@schema("public")
}

model LessonPlanPart {
  id           String                      @id @default(cuid())
  lessonPlanId String                      @map("lesson_plan_id")
  subjectId    String?                     @map("subject_id")
  keyStageId   String?                     @map("key_stage_id")
  key          String
  content      String
  json         Json?
  createdAt    DateTime                    @default(now()) @map("created_at")
  updatedAt    DateTime                    @updatedAt @map("updated_at")
  lessonPlan   LessonPlan                  @relation(fields: [lessonPlanId], references: [id], onDelete: Cascade)
  subject      Subject?                    @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  keyStage     KeyStage?                   @relation(fields: [keyStageId], references: [id], onDelete: Cascade)
  embedding    Unsupported("vector(256)")?
  status       LessonPlanPartStatus        @default(PENDING)

  @@unique([lessonPlanId, key])
  @@map("lesson_plan_parts")
  @@schema("public")
}

model Transcript {
  id        String            @id @default(cuid())
  createdAt DateTime          @default(now()) @map("created_at")
  updatedAt DateTime          @updatedAt @map("updated_at")
  variant   TranscriptVariant @default(ORIGINAL)
  lessonId  String            @map("lesson_id")
  content   Json?             @map("content")
  status    TranscriptStatus  @default(PENDING)
  snippets  Snippet[]

  lesson Lesson @relation(fields: [lessonId], references: [id], onDelete: Cascade)

  @@unique([lessonId, variant])
  @@map("transcripts")
  @@schema("public")
}

// The aggregate of many Generations, combined into
// one final output, e.g. a quiz or a document
model AppSession {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  app   App    @relation(fields: [appId], references: [id], onDelete: Cascade)
  appId String @map("app_id")

  userId String @map("user_id") // The user that requested this generation

  output Json? // The final output of the session

  userTweaks          UserTweak[]
  reGenerations       ReGeneration[]
  generationUserFlags GenerationUserFlag[]
  moderations         Moderation[]

  @@map("app_sessions")
  @@schema("public")
}

model SharedContent {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  userId       String   @map("user_id")
  content      Json
  appSessionId String   @map("app_session_id")

  @@map("shared_content")
  @@schema("public")
}

// A single request & response cycle from the user
// to an AI model. The result of "applying" a Prompt
model Generation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  appId String @map("app_id")

  promptId String @map("prompt_id")

  appSessionId String? @map("app_session_id")
  messageId    String? @map("message_id")
  userId       String  @map("user_id") // The user that requested this generation

  status               GenerationStatus @default(REQUESTED)
  promptInputs         Json?            @map("prompt_inputs") // Stores the prompt inputs used to generate the response
  promptText           String?          @map("prompt_text") // Stores the prompt that was used to generate the response
  response             Json? // Stores the raw text response
  llmTimeTaken         Int?             @map("llm_time_taken") // LLM time taken
  completedAt          DateTime?        @map("completed_at") // When we finished the generation, duration = completedAt-createdAt
  error                String? // The error message associated with this
  moderationType       ModerationType?  @map("moderation_type")
  moderationMeta       Json?            @map("moderation_meta") // Useful metadata about the moderation
  moderationResults    Json? // The OpenAI moderation scores for the user input
  promptTokensUsed     Int?             @map("prompt_tokens_used")
  completionTokensUsed Int?             @map("completion_tokens_used")
  promptInputsHash     String?          @map("prompt_inputs_hash") // A hash of the prompt input to be used for replaying past responses

  userTweaks             UserTweak[]
  originalGenerations    ReGeneration[]       @relation("previous_generation")
  generationUserFlags    GenerationUserFlag[]
  replacementGenerations ReGeneration[]       @relation("replacement_generation")

  @@index([promptInputsHash, promptId, status])
  @@map("generations")
  @@schema("public")
}

model UserTweak {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  appSession   AppSession? @relation(fields: [appSessionId], references: [id], onDelete: Cascade)
  appSessionId String?     @map("app_session_id")

  generation   Generation @relation(fields: [generationId], references: [id], onDelete: Cascade)
  generationId String     @map("generation_id")

  // The manual tweak a user has made, note this is currently for a part of a generation
  // e.g. a single quiz distractor, rather than the whole updated JSON object
  tweakedValue  Json  @map("tweaked_value")
  originalValue Json? @map("original_value") // Optional for back-compat / non breaking changes

  @@map("user_tweaks")
  @@schema("public")
}

model ReGeneration {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  appSession   AppSession? @relation(fields: [appSessionId], references: [id], onDelete: Cascade)
  appSessionId String?     @map("app_session_id")

  previousGenerationId    String     @map("previous_generation_id")
  previousGeneration      Generation @relation("previous_generation", fields: [previousGenerationId], references: [id], onDelete: Cascade)
  replacementGenerationId String     @map("replacement_generation_id")
  replacementGeneration   Generation @relation("replacement_generation", fields: [replacementGenerationId], references: [id], onDelete: Cascade)

  @@map("re_generations")
  @@schema("public")
}

model GenerationUserFlag {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  appSession   AppSession? @relation(fields: [appSessionId], references: [id], onDelete: Cascade)
  appSessionId String?     @map("app_session_id")

  generation   Generation @relation(fields: [generationId], references: [id], onDelete: Cascade)
  generationId String     @map("generation_id")

  feedbackMessage String? @map("feedback_message")
  feedbackValue   String  @map("feedback_value") // The fragment of the generation that feedback was given on
  feedbackReasons Json

  @@map("generation_user_flags")
  @@schema("public")
}

model Snippet {
  id            String                       @id @default(cuid())
  lessonId      String                       @map("lesson_id")
  transcriptId  String?                      @map("transcript_id")
  questionId    String?                      @map("question_id")
  index         Int?
  variant       SnippetVariant               @default(SENTENCE)
  timestamp     Int?
  sourceContent String                       @map("source_content")
  content       String
  embedding     Unsupported("vector(1536)")?
  compression   SnippetCompression?
  status        SnippetStatus                @default(PENDING)
  createdAt     DateTime                     @default(now()) @map("created_at")
  updatedAt     DateTime                     @updatedAt @map("updated_at")
  keyStageSlug  String?                      @map("key_stage_slug")
  subjectSlug   String?                      @map("subject_slug")
  keyStageId    String?                      @map("key_stage_id")
  subjectId     String?                      @map("subject_id")

  lesson     Lesson        @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  transcript Transcript?   @relation(fields: [transcriptId], references: [id], onDelete: Cascade)
  question   QuizQuestion? @relation(fields: [questionId], references: [id], onDelete: Cascade)
  keyStage   KeyStage?     @relation(fields: [keyStageId], references: [id], onDelete: Cascade)
  subject    Subject?      @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  @@unique([lessonId, transcriptId, index, compression, variant])
  @@map("snippets")
  @@schema("public")
}

model QuizQuestion {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  originalQuestionId Int                          @unique @map("original_question_id")
  lessonId           String                       @map("lesson_id")
  question           String
  embedding          Unsupported("vector(1536)")?
  status             QuizQuestionStatus           @default(PENDING)

  lesson   Lesson       @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  answers  QuizAnswer[]
  snippets Snippet[]

  QuestionsForJudgement             QuestionsForJudgement[]
  AnswersAndDistractorsForJudgement AnswersAndDistractorsForJudgement[]

  @@map("questions")
  @@schema("public")
}

model QuizAnswer {
  id         String                       @id @default(cuid())
  createdAt  DateTime                     @default(now()) @map("created_at")
  updatedAt  DateTime                     @updatedAt @map("updated_at")
  questionId String                       @map("question_id")
  lessonId   String                       @map("lesson_id")
  answer     String
  distractor Boolean                      @default(false)
  embedding  Unsupported("vector(1536)")?
  status     QuizAnswerStatus             @default(PENDING)

  lesson Lesson @relation(fields: [lessonId], references: [id], onDelete: Cascade)

  question QuizQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([lessonId, questionId, answer])
  @@map("answers")
  @@schema("public")
}

model Statistics {
  id          String   @id @default(uuid())
  name        String
  value       Int
  lastUpdated DateTime @map("last_updated")

  apps     App[]
  appId    String?  @map("app_id")
  prompts  Prompt[]
  promptId String?  @map("prompt_id")

  @@unique([name, appId, promptId])
  @@map("statistics")
  @@schema("public")
}

model QuestionsForJudgement {
  id                   String                 @id @default(cuid())
  createdAt            DateTime               @default(now()) @map("created_at")
  updatedAt            DateTime               @updatedAt @map("updated_at")
  quizQuestionId       String?                @map("quiz_question_id")
  quizQuestion         QuizQuestion?          @relation(fields: [quizQuestionId], references: [id], onDelete: Cascade)
  subjectId            String                 @map("subject_id")
  subject              Subject                @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  keyStageId           String                 @map("key_stage_id")
  keyStage             KeyStage               @relation(fields: [keyStageId], references: [id], onDelete: Cascade)
  ComparativeJudgement ComparativeJudgement[]

  @@map("questions_for_judgement")
  @@schema("public")
}

model AnswersAndDistractorsForJudgement {
  id                  String        @id @default(cuid())
  createdAt           DateTime      @default(now()) @map("created_at")
  updatedAt           DateTime      @updatedAt @map("updated_at")
  quizQuestionId      String?       @map("quiz_question_id")
  quizQuestion        QuizQuestion? @relation(fields: [quizQuestionId], references: [id], onDelete: Cascade)
  answerAndDistractor Json          @map("answer_and_distractor")
  isOakQuestion       Boolean?      @map("is_oak_question")
  promptId            String?       @map("prompt_id")
  prompt              Prompt?       @relation(fields: [promptId], references: [id], onDelete: Cascade)

  comparativeJudgementA ComparativeJudgement[] @relation("OptionA")
  comparativeJudgementB ComparativeJudgement[] @relation("OptionB")

  ComparativeJudgementResult ComparativeJudgementResult[]
  ComparativeJudgementFlag   ComparativeJudgementFlag[]

  @@map("answers_and_distractors_for_judgement")
  @@schema("public")
}

model ComparativeJudgement {
  id                          String                            @id @default(cuid())
  createdAt                   DateTime                          @default(now()) @map("created_at")
  updatedAt                   DateTime                          @updatedAt @map("updated_at")
  questionForJudgementId      String                            @map("question_for_judgement_id")
  questionForJudgement        QuestionsForJudgement             @relation(fields: [questionForJudgementId], references: [id], onDelete: Cascade)
  optionAId                   String                            @map("option_a_id")
  optionA                     AnswersAndDistractorsForJudgement @relation("OptionA", fields: [optionAId], references: [id], onDelete: Cascade)
  optionBId                   String                            @map("option_b_id")
  optionB                     AnswersAndDistractorsForJudgement @relation("OptionB", fields: [optionBId], references: [id], onDelete: Cascade)
  ComparativeJudgementResults ComparativeJudgementResult[]
  ComparativeJudgementFlag    ComparativeJudgementFlag[]

  @@map("comparative_judgements")
  @@schema("public")
}

model ComparativeJudgementResult {
  id                      String                             @id @default(cuid())
  createdAt               DateTime                           @default(now()) @map("created_at")
  updatedAt               DateTime                           @updatedAt @map("updated_at")
  judgementId             String                             @map("judgement_id")
  judgement               ComparativeJudgement               @relation(fields: [judgementId], references: [id], onDelete: Cascade)
  winnerId                String?                            @map("winner_id")
  winner                  AnswersAndDistractorsForJudgement? @relation(fields: [winnerId], references: [id], onDelete: Cascade)
  userId                  String                             @map("user_id")
  flaggedOrSkipped        FlaggedOrSkipped?                  @map("flagged_or_skipped")
  reasonForChoosingWinner String?                            @map("decision_reason")

  @@map("comparative_judgement_results")
  @@schema("public")
}

model ComparativeJudgementFlag {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  flaggedJudgementId String               @map("flagged_judgement_id")
  flaggedJudgement   ComparativeJudgement @relation(fields: [flaggedJudgementId], references: [id], onDelete: Cascade)

  flaggedAnswerAndDistractorId String                            @map("flagged_answer_and_distractor_id")
  flaggedAnswerAndDistractor   AnswersAndDistractorsForJudgement @relation(fields: [flaggedAnswerAndDistractorId], references: [id], onDelete: Cascade)

  feedbackMessage String @map("feedback_message")
  feedbackReasons Json

  @@map("comparative_judgement_flags")
  @@schema("public")
}

model Downloads {
  id         Int      @id @default(autoincrement())
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")
  lessonSlug String   @map("lesson_slug")
  download   Json

  lesson Lesson @relation(fields: [lessonSlug], references: [slug], onDelete: Cascade)

  @@map("downloads")
  @@schema("public")
}

model UsersAllowedToViewNewFeatures {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  emailAddress String @map("email_address")

  @@map("users_allowed_to_view_new_features")
  @@schema("public")
}

model LessonExportDownload {
  id             String   @id @default(cuid())
  ext            String   @map("ext")
  lessonExportId String   @map("lesson_export_id")
  downloadedBy   String   @map("downloaded_by")
  createdAt      DateTime @default(now()) @map("created_at")

  lessonExport LessonExport @relation(fields: [lessonExportId], references: [id], onDelete: Cascade)

  @@map("lesson_export_downloads")
  @@schema("public")
}

model QdExportDownload {
  id           String   @id @default(cuid())
  ext          String   @map("ext")
  qdExportId   String   @map("qd_export_id")
  downloadedBy String   @map("downloaded_by")
  createdAt    DateTime @default(now()) @map("created_at")

  qdExport QdExport @relation(fields: [qdExportId], references: [id], onDelete: Cascade)

  @@map("qd_export_downloads")
  @@schema("public")
}

model QdExport {
  id                    String           @id @default(cuid())
  snapshotId            String           @map("lesson_snapshot_id")
  exportType            LessonExportType @map("export_type")
  templateGdriveFileId  String           @map("template_gdrive_file_id")
  gdriveFileId          String           @map("gdrive_file_id")
  gdriveFileUrl         String           @map("gdrive_file_url")
  createdAt             DateTime         @default(now()) @map("created_at")
  updatedAt             DateTime         @updatedAt @map("updated_at")
  expiredAt             DateTime?        @map("expired_at")
  // generally this is if the user's email is associated with a Google Drive account
  userCanViewGdriveFile Boolean          @map("user_can_view_gdrive_file")
  userId                String           @map("user_id")

  qdSnapshot        QdSnapshot         @relation(fields: [snapshotId], references: [id], onDelete: Cascade)
  qdExportDownloads QdExportDownload[]

  @@index([userId, gdriveFileId], name: "idx_qd_user_grdive_file_id")
  @@map("qd_exports")
  @@schema("public")
}

model QdSnapshot {
  id        String @id @default(cuid())
  sessionId String @map("session_id")
  messageId String @map("message_id")
  qdJson    Json   @map("qd_json") @db.JsonB

  // sha256 hash of the lessonJson
  hash      String
  trigger   LessonSnapshotTrigger @map("trigger")
  createdAt DateTime              @default(now()) @map("created_at")
  updatedAt DateTime              @updatedAt @map("updated_at")
  userId    String?               @map("user_id")

  qdExports QdExport[]

  @@index([userId, sessionId, hash], name: "idx_qd_user_session_hash")
  @@map("qd_snapshots")
  @@schema("public")
}

model LessonExport {
  id                    String           @id @default(cuid())
  lessonSnapshotId      String           @map("lesson_snapshot_id")
  exportType            LessonExportType @map("export_type")
  templateGdriveFileId  String           @map("template_gdrive_file_id")
  gdriveFileId          String           @map("gdrive_file_id")
  gdriveFileUrl         String           @map("gdrive_file_url")
  createdAt             DateTime         @default(now()) @map("created_at")
  updatedAt             DateTime         @updatedAt @map("updated_at")
  expiredAt             DateTime?        @map("expired_at")
  // generally this is if the user's email is associated with a Google Drive account
  userCanViewGdriveFile Boolean          @map("user_can_view_gdrive_file")
  userId                String           @map("user_id")

  lessonSnapshot        LessonSnapshot         @relation(fields: [lessonSnapshotId], references: [id], onDelete: Cascade)
  lessonExportDownloads LessonExportDownload[]

  @@index([userId, gdriveFileId], name: "idx_user_grdive_file_id")
  @@map("lesson_exports")
  @@schema("public")
}

model LessonSnapshot {
  id             String                @id @default(cuid())
  chatId         String                @map("chat_id")
  messageId      String                @map("message_id")
  lessonJson     Json                  @map("lesson_json") @db.JsonB
  lessonSchemaId Int                   @map("lesson_schema_id")
  // sha256 hash of the lessonJson
  hash           String
  trigger        LessonSnapshotTrigger @map("trigger")
  createdAt      DateTime              @default(now()) @map("created_at")
  updatedAt      DateTime              @updatedAt @map("updated_at")
  userId         String?               @map("user_id")

  lessonSchema  LessonSchema   @relation(fields: [lessonSchemaId], references: [id], onDelete: Cascade)
  lessonExports LessonExport[]
  moderations   Moderation[]

  @@index([userId, chatId, hash], name: "idx_user_chat_hash")
  @@map("lesson_snapshots")
  @@schema("public")
}

model Moderation {
  id               String    @id @default(cuid())
  createdAt        DateTime  @default(now()) @map("created_at")
  updatedAt        DateTime  @updatedAt @map("updated_at")
  userId           String    @map("user_id")
  appSessionId     String    @map("app_session_id")
  messageId        String    @map("message_id")
  categories       Json[]
  scores           Json?     @map("scores") @db.JsonB
  justification    String?
  lessonSnapshotId String?   @map("lesson_snapshot_id")
  // A user's comment in relation to the moderation. Likely they are contesting it.
  userComment      String?   @map("user_comment")
  invalidatedAt    DateTime? @map("invalidated_at")
  invalidatedBy    String?   @map("invalidated_by")

  appSession     AppSession?     @relation(fields: [appSessionId], references: [id], onDelete: Cascade)
  lessonSnapshot LessonSnapshot? @relation(fields: [lessonSnapshotId], references: [id], onDelete: Cascade)

  @@map("moderations")
  @@schema("public")
}

model LessonSchema {
  id              Int              @id @default(autoincrement())
  // sha256 hash of the jsonSchema
  hash            String
  jsonSchema      Json             @map("json_schema") @db.JsonB
  createdAt       DateTime         @default(now()) @map("created_at")
  updatedAt       DateTime         @updatedAt @map("updated_at")
  lessonSnapshots LessonSnapshot[]

  @@index([hash])
  @@map("lesson_schemas")
  @@schema("public")
}

model SafetyViolation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  userId          String                    @map("user_id")
  userAction      SafetyViolationAction     @map("user_action")
  detectionSource SafetyViolationSource     @map("detection_source")
  recordType      SafetyViolationRecordType @map("record_type")
  recordId        String                    @map("record_id")

  @@map("policy_violations")
  @@schema("public")
}

enum SafetyViolationAction {
  CHAT_MESSAGE
  QUIZ_GENERATION
  PARTIAL_LESSON_GENERATION
  ADDITIONAL_MATERIAL_GENERATION

  @@schema("public")
}

enum SafetyViolationSource {
  HELICONE
  OPENAI
  MODERATION
  THREAT

  @@schema("public")
}

enum SafetyViolationRecordType {
  CHAT_SESSION
  GENERATION
  MODERATION
  ADDITIONAL_MATERIAL_SESSION

  @@schema("public")
}

enum LessonExportType {
  STARTER_QUIZ_DOC
  EXIT_QUIZ_DOC
  LESSON_PLAN_DOC
  LESSON_SLIDES_SLIDES
  WORKSHEET_SLIDES
  ADDITIONAL_MATERIALS_DOCS

  @@schema("public")
}

enum LessonSnapshotTrigger {
  ASSISTANT_MESSAGE
  EXPORT_BY_USER
  MODERATION

  @@schema("public")
}

enum FlaggedOrSkipped {
  FLAGGED
  SKIPPED

  @@schema("public")
}

enum SnippetVariant {
  SENTENCE
  PARAGRAPH
  SECTION
  CHUNK
  VTT
  QUESTION_AND_ANSWER

  @@schema("public")
}

enum GenerationStatus {
  REQUESTED //  User has requested a generation
  PENDING //    The backend has picked up the request and began processing
  MODERATING // The request is undergoing moderation
  GENERATING // The request is being generated by the LLM
  FAILED //     An error occurred processing the generation
  SUCCESS //    We got a valid response from the LLM
  FLAGGED //    It failed moderation, or the LLM refused to answer. See ModerationType

  @@schema("public")
}

enum ModerationType {
  NOT_ENGLISH
  PROFANITY
  OPENAI_FLAGGED
  OPENAI_OVER_THRESHOLD
  LLM_REFUSAL

  @@schema("public")
}

enum TranscriptVariant {
  ORIGINAL
  COMPRESSED

  @@schema("public")
}

enum TranscriptStatus {
  PENDING
  FAILED
  SUCCESS

  @@schema("public")
}

enum SnippetStatus {
  PENDING
  FAILED
  SUCCESS

  @@schema("public")
}

enum LessonSummaryStatus {
  PENDING
  GENERATED
  FAILED
  SUCCESS

  @@schema("public")
}

enum LessonPlanStatus {
  PENDING
  GENERATED
  FAILED
  SUCCESS

  @@schema("public")
}

enum LessonPlanPartStatus {
  PENDING
  GENERATED
  FAILED
  SUCCESS

  @@schema("public")
}

enum SnippetCompression {
  BREVITY
  SIMPLIFICATION
  RELEVANCE

  @@schema("public")
}

enum QuizQuestionStatus {
  PENDING
  FAILED
  SUCCESS

  @@schema("public")
}

enum QuizAnswerStatus {
  PENDING
  FAILED
  SUCCESS

  @@schema("public")
}

model Ingest {
  id          String    @id @default(cuid())
  config      Json      @map("config") @db.JsonB
  status      String
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  completedAt DateTime? @map("completed_at")

  ingestLessons           IngestLesson[]
  ingestLessonTranscripts IngestLessonCaptions[]
  ingestLessonPlans       IngestLessonPlan[]
  ingestLessonPlanParts   IngestLessonPlanPart[]
  ingestErrors            IngestError[]
  ingestOpenAiBatches     IngestOpenAiBatch[]

  @@map("ingest")
  @@schema("ingest")
}

model IngestLesson {
  id          String   @id @default(cuid())
  oakLessonId Int      @map("oak_lesson_id")
  ingestId    String   @map("ingest_id")
  data        Json     @map("data") @db.JsonB
  dataHash    String   @map("data_hash")
  step        String
  stepStatus  String   @map("step_status")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  ingest          Ingest                 @relation(fields: [ingestId], references: [id])
  ingestErrors    IngestError[]
  lessonPlanParts IngestLessonPlanPart[]
  captions        IngestLessonCaptions?
  lessonPlan      IngestLessonPlan?

  @@map("ingest_lesson")
  @@schema("ingest")
}

model IngestLessonCaptions {
  id        String   @id @default(cuid())
  ingestId  String   @map("ingest_id")
  lessonId  String   @unique @map("lesson_id")
  data      Json     @map("data") @db.JsonB
  dataHash  String   @map("data_hash")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  ingest       Ingest       @relation(fields: [ingestId], references: [id])
  ingestLesson IngestLesson @relation(fields: [lessonId], references: [id])

  @@map("ingest_lesson_captions")
  @@schema("ingest")
}

model IngestLessonPlan {
  id        String   @id @default(cuid())
  ingestId  String   @map("ingest_id")
  lessonId  String   @unique @map("lesson_id")
  batchId   String   @map("batch_id")
  data      Json?    @map("data") @db.JsonB
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  ingest                Ingest                 @relation(fields: [ingestId], references: [id])
  ingestLesson          IngestLesson           @relation(fields: [lessonId], references: [id])
  ingestLessonPlanParts IngestLessonPlanPart[]

  @@map("ingest_lesson_plan")
  @@schema("ingest")
}

model IngestLessonPlanPart {
  id           String                      @id @default(cuid())
  lessonId     String                      @map("lesson_id")
  lessonPlanId String                      @map("lesson_plan_id")
  ingestId     String                      @map("ingest_id")
  batchId      String?                     @map("batch_id")
  key          String
  valueJson    Json                        @map("value_json") @db.JsonB
  valueText    String                      @map("value_text")
  embedding    Unsupported("vector(256)")?
  createdAt    DateTime                    @default(now()) @map("created_at")
  updatedAt    DateTime                    @updatedAt @map("updated_at")

  ingest           Ingest           @relation(fields: [ingestId], references: [id])
  lesson           IngestLesson?    @relation(fields: [lessonId], references: [id])
  ingestLessonPlan IngestLessonPlan @relation(fields: [lessonPlanId], references: [id])

  @@map("ingest_lesson_plan_part")
  @@schema("ingest")
}

model IngestOpenAiBatch {
  id            String    @id @default(cuid())
  ingestId      String    @map("ingest_id")
  inputFilePath String    @map("input_file_path")
  outputFileId  String?   @map("output_file_id")
  errorFileId   String?   @map("error_file_id")
  openaiBatchId String    @map("openai_batch_id")
  status        String
  submittedAt   DateTime  @default(now()) @map("submitted_at")
  receivedAt    DateTime? @map("received_at")
  errorMessage  String?   @map("error_message")
  batchType     String    @map("batch_type")

  ingest Ingest @relation(fields: [ingestId], references: [id])

  @@map("ingest_openai_batch")
  @@schema("ingest")
}

model IngestError {
  id           String   @id @default(cuid())
  ingestId     String   @map("ingest_id")
  lessonId     String?  @map("lesson_id")
  step         String
  errorMessage String   @map("error_message")
  createdAt    DateTime @default(now()) @map("created_at")

  ingest Ingest        @relation(fields: [ingestId], references: [id])
  lesson IngestLesson? @relation(fields: [lessonId], references: [id])

  @@map("ingest_error")
  @@schema("ingest")
}

model RagLessonPlan {
  id                 String              @id @default(cuid())
  oakLessonId        Int?                @map("oak_lesson_id")
  oakLessonSlug      String              @map("oak_lesson_slug")
  ingestLessonId     String?             @map("ingest_lesson_id")
  lessonPlan         Json                @map("lesson_plan") @db.JsonB
  subjectSlug        String              @map("subject_slug")
  keyStageSlug       String              @map("key_stage_slug")
  isPublished        Boolean             @default(false) @map("is_published")
  createdAt          DateTime            @default(now()) @map("created_at")
  updatedAt          DateTime            @updatedAt @map("updated_at")
  ragLessonPlanParts RagLessonPlanPart[]
  // The following index is not supported by prisma so is applied manually in ./additions/rag_lesson_plans_unique_slug_index.sql
  //  @@index([oakLessonSlug], name: "unique_published_oak_lesson_slug", dbIndex: false) @db.PartialIndex("is_published = TRUE")

  @@index([isPublished, keyStageSlug, subjectSlug], name: "idx_rag_lesson_plans_published_key_stage_subject")
  @@map("rag_lesson_plans")
  @@schema("rag")
}

model RagLessonPlanPart {
  id              String   @id @default(cuid())
  ragLessonPlanId String   @map("rag_lesson_plan_id")
  key             String
  valueText       String   @map("value_text")
  valueJson       Json     @map("value_json") @db.JsonB
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  ragLessonPlan RagLessonPlan              @relation(fields: [ragLessonPlanId], references: [id], onDelete: Cascade)
  embedding     Unsupported("vector(256)")

  @@map("rag_lesson_plan_parts")
  @@schema("rag")
}

model AdditionalMaterialInteraction {
  id     String @id @default(uuid())
  userId String @map("user_id")

  derivedFromId String?                         @map("derived_from_id")
  derivedFrom   AdditionalMaterialInteraction?  @relation("DerivedFrom", fields: [derivedFromId], references: [id])
  derivatives   AdditionalMaterialInteraction[] @relation("DerivedFrom")

  adaptsOutputId String?                         @map("adapts_output_id")
  adaptsOutput   AdditionalMaterialInteraction?  @relation("AdaptedOutput", fields: [adaptsOutputId], references: [id])
  adaptedBy      AdditionalMaterialInteraction[] @relation("AdaptedOutput")

  config               Json    @db.JsonB
  inputText            String? @map("input_text")
  inputThreatDetection Json?   @map("input_threat_detection") @db.JsonB

  output           Json? @db.JsonB
  outputModeration Json? @map("output_moderation") @db.JsonB

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("AdditionalMaterialInteractions")
  @@schema("public")
}
